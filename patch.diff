From f784ddcf195d77baabc6c1ca478ee9276dcca3ba Mon Sep 17 00:00:00 2001
From: Wolfgang Bumiller <wry.git@bumiller.com>
Date: Mon, 23 Dec 2013 12:40:54 +0100
Subject: [PATCH 2/2] implement channel_process, with a cmd_channel_timeout
 split function also used in cmd_channel_destroy to allow the thread to
 gracefully exit unless it's timing out; also fixed cmd_channel_wrclose: has
 to signal, not wait for the condition-variable

---
 command.c | 101 +++++++++++++++++++++++++++++++++++++++++++++-----------------
 command.h |   1 +
 2 files changed, 75 insertions(+), 27 deletions(-)

diff --git a/command.c b/command.c
index 22f6900..9bce2b2 100644
--- a/command.c
+++ b/command.c
@@ -7,6 +7,7 @@
 #include <string.h>
 #include <stdio.h>
 #include <time.h>
+#include <unistd.h>
 
 struct cmd_link_s {
     cmd_entry_t *data;
@@ -24,6 +25,9 @@ struct cmd_channel_s {
     volatile bool   wrend;
     void          (*destroy)(cmd_entry_t *);
     bool            ready;
+    time_t          cmd_time;
+    cmd_entry_t    *cmd_entry;
+    pthread_mutex_t cmd_mutex;
 };
 
 struct cmd_entry_s {
@@ -48,30 +52,34 @@ void cmd_link_destroy(cmd_link_t *link, void (*destroy)(cmd_entry_t *)) {
 cmd_channel_t *cmd_channel_create(void) {
     cmd_channel_t *channel = malloc(sizeof(*channel));
 
-    pthread_mutex_init(&channel->mutex, NULL);
-    pthread_cond_init (&channel->waiter, NULL);
+    pthread_mutex_init(&channel->mutex,     NULL);
+    pthread_mutex_init(&channel->cmd_mutex, NULL);
+    pthread_cond_init (&channel->waiter,    NULL);
 
-    channel->head     = cmd_link_create();
-    channel->tail     = channel->head;
-    channel->rdintent = NULL;
-    channel->rdend    = false;
-    channel->wrend    = false;
-    channel->destroy  = NULL;
-    channel->ready    = false;
+    channel->head      = cmd_link_create();
+    channel->tail      = channel->head;
+    channel->rdintent  = NULL;
+    channel->rdend     = false;
+    channel->wrend     = false;
+    channel->destroy   = NULL;
+    channel->ready     = false;
+    channel->cmd_time  = 0;
+    channel->cmd_entry = NULL;
 
     return channel;
 }
 
 void cmd_channel_destroy(cmd_channel_t *channel) {
-    cmd_channel_rdclose(channel);
+    cmd_channel_wrclose(channel);
+    if (cmd_channel_timeout(channel))
+        cmd_entry_destroy(channel->cmd_entry);
+    else
+        pthread_join(channel->thread, NULL);
 
     pthread_mutex_destroy(&channel->mutex);
+    pthread_mutex_destroy(&channel->cmd_mutex);
     pthread_cond_destroy (&channel->waiter);
 
-    // kill thread
-    pthread_kill(channel->thread, SIGUSR2);
-    pthread_join(channel->thread, NULL);
-
     cmd_link_t *link = channel->head;
     while (link) {
         cmd_link_t *next = link->next;
@@ -133,7 +141,7 @@ void cmd_channel_wrclose(cmd_channel_t *channel) {
     if (channel->rdintent == channel->tail) {
         pthread_mutex_lock(&channel->mutex);
         if (channel->rdintent == channel->tail)
-            pthread_cond_wait(&channel->waiter, &channel->mutex);
+            pthread_cond_signal(&channel->waiter);
         pthread_mutex_unlock(&channel->mutex);
     }
 }
@@ -187,20 +195,25 @@ static void *cmd_channel_threader(void *data) {
     cmd_channel_t *channel = data;
     cmd_entry_t   *entry   = NULL;
 
-    for(;;) {
-        while (cmd_channel_pop(channel, &entry)) {
-            if (entry->method) {
-                entry->method(
-                    entry->instance,
-                    string_contents(entry->channel),
-                    string_contents(entry->user),
-                    string_contents(entry->message)
-                );
-                cmd_entry_destroy(entry);
-            }
+    while (cmd_channel_pop(channel, &entry)) {
+        if (entry->method) {
+            channel->cmd_time = time(NULL);
+            channel->cmd_entry = entry;
+            entry->method(
+                entry->instance,
+                string_contents(entry->channel),
+                string_contents(entry->user),
+                string_contents(entry->message)
+            );
+            pthread_mutex_lock(&channel->cmd_mutex);
+            cmd_entry_destroy(entry);
+            channel->cmd_time = 0;
+            channel->cmd_entry = NULL;
+            pthread_mutex_unlock(&channel->cmd_mutex);
         }
     }
 
+    cmd_channel_rdclose(channel);
     return NULL;
 }
 
@@ -221,6 +234,40 @@ bool cmd_channel_ready(cmd_channel_t *channel) {
     return channel->ready;
 }
 
+bool cmd_channel_timeout(cmd_channel_t *channel) {
+    if (!channel->cmd_time || channel->cmd_time + 3 >= time(NULL))
+        return false;
+    // a command timed out:
+    pthread_mutex_lock(&channel->cmd_mutex);
+    // it's possible the thread locked the mutex first, which means the command
+    // took _exactly_ as much time as allowed, so we need to recheck
+    // for whether the command actually did time out:
+    if (!channel->cmd_time || channel->cmd_time + 3 >= time(NULL)) {
+        // it didn't
+        pthread_mutex_unlock(&channel->cmd_mutex);
+        return false;
+    }
+    // now we send the kill signal
+    pthread_kill(channel->thread, SIGUSR2);
+    pthread_join(channel->thread, NULL);
+    pthread_mutex_unlock(&channel->cmd_mutex);
+    return true;
+}
+
 void cmd_channel_process(cmd_channel_t *channel) {
-    // TODO: consult blub
+    if (!cmd_channel_timeout(channel))
+        return;
+
+    // the entry is ours now, we need to clean this up:
+    cmd_entry_t *entry = channel->cmd_entry;
+    channel->cmd_entry = NULL;
+    channel->cmd_time  = 0;
+
+    irc_write(entry->instance, string_contents(entry->channel), "command timed out");
+
+    cmd_entry_destroy(entry);
+
+    // reopen the reading end
+    channel->rdend = false;
+    cmd_channel_begin(channel);
 }
diff --git a/command.h b/command.h
index 8a14cbe..5cb849b 100644
--- a/command.h
+++ b/command.h
@@ -23,6 +23,7 @@ void cmd_channel_wrclose(cmd_channel_t *channel);
 bool cmd_channel_push(cmd_channel_t *channel, cmd_entry_t *entry);
 bool cmd_channel_begin(cmd_channel_t *channel);
 bool cmd_channel_ready(cmd_channel_t *channel);
+bool cmd_channel_timeout(cmd_channel_t *channel);
 void cmd_channel_process(cmd_channel_t *channel);
 cmd_channel_t *cmd_channel_create(void);
 void cmd_channel_destroy(cmd_channel_t *channel);
-- 
1.8.4


